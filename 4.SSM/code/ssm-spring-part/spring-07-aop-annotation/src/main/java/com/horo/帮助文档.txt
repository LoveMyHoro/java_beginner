1.代理模式

(1)二十三种设计模式中的一种，属于结构型模式。它的作用就是通过提供一个代理类，让我们在调用目标方法的时候，
不再是直接对目标方法进行调用，而是通过代理类间接调用。让不属于目标方法核心逻辑的代码从目标方法中剥离出来——解耦。
调用目标方法时先调用代理对象的方法，减少对目标方法的调用和打扰，同时让附加功能能够集中在一起也有利于统一维护。

(2)代理：将非核心逻辑剥离出来以后，封装这些非核心逻辑的类、对象、方法。(中介)

  -   动词：指做代理这个动作，或这项工作
  -   名词：扮演代理这个角色的类、对象、方法

(3)代理在开发中实现的方式具体有两种：静态代理，动态代理技术
一般在开发中只使用动态代理

(4)动态代理技术分类

  JDK动态代理：JDK原生的实现方式，需要被代理的目标类必须**实现接口**！他会根据目标类的接口动态生成一个代理对象！代理对象和目标对象有相同的接口！（拜把子）
  cglib：通过继承被代理的目标类实现代理，所以不需要目标类实现接口！（认干爹）

2.Aop利用代理技术解决非核心代码的冗余问题

    (1)Aop将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，
    降低模块之间的耦合度，并有利于未来的可操作性和可维护性。
    (2)Aop类似与数学中的提取公因式

3.Aop的8个核心名词
    (1)横切关注点：非核心的代码
        AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。
        横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事务、异常等。
        AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。
    (2)通知(增强)：切入的时机
        -   前置通知：在被代理的目标方法前执行
        -   返回通知：在被代理的目标方法成功结束后执行（**寿终正寝**）
        -   异常通知：在被代理的目标方法异常结束后执行（**死于非命**）
        -   后置通知：在被代理的目标方法最终结束后执行（**盖棺定论**）
        -   环绕通知：使用try...catch...finally结构围绕整个被代理的目标方法，包括上面四种通知对应的所有位置
    (3)连接点 joinpoint：可以被切入的目标方法
    (4)切入点 pointcut：选择切入的目标方法。切点一定是连接点，但连接点不一定是切点
    (5)切面 aspect：切入点形成的面。切点+增强=切面
    (6)目标 target：切入的对象
    (7)代理 proxy：切入之后创建的代理对象。
    (8)织入 weave：切入的动作叫做织入，